//! Merkle Tree-Backed ZK Circuit for Exploit Proofs
//!
//! This circuit allows auditors to prove they know specific exploit patterns
//! within a markdown report without revealing the full report content.
//!
//! ## Circuit Overview
//! 
//! The circuit proves:
//! 1. Knowledge of a markdown report split into fixed-size chunks
//! 2. These chunks form leaves of a Merkle tree with a public root
//! 3. A specific exploit signature exists contiguously in the leaf set
//! 4. The report is bound to a specific contract address
//!
//! ## Privacy Guarantees
//! 
//! - **Private**: Full markdown report content, exact location of exploit
//! - **Public**: Merkle root, contract address, fact that exploit exists
use ark_ff::PrimeField;
use ark_r1cs_std::{
    alloc::AllocVar,
    boolean::Boolean,
    eq::EqGadget,
    fields::{fp::FpVar, FieldVar},
    R1CSVar,
};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError};

#[derive(Debug, Clone)]
pub struct ExploitMerkleConfig {
    pub chunk_size: usize,
    pub tree_height: u32,
    pub max_exploit_chunks: usize,
}

impl Default for ExploitMerkleConfig {
    fn default() -> Self {
        Self {
            chunk_size: 32,
            tree_height: 20,
            max_exploit_chunks: 16,
        }
    }
}

#[derive(Debug, Clone)]
pub struct SimpleMerkleTree {
    pub root: Vec<u8>,
    pub leaves: Vec<Vec<u8>>,
    pub height: u32,
}

#[derive(Debug, Clone)]
pub struct ExploitChunks {
    pub chunk_indices: Vec<usize>,
    pub chunk_data: Vec<Vec<u8>>,
    pub merkle_paths: Vec<Vec<Vec<u8>>>,
}

#[derive(Clone)]
pub struct ExploitMerkleCircuit<F: PrimeField> {
    pub merkle_root: Option<F>,
    pub contract_address: Option<F>,
    pub exploit_chunks: Vec<Option<F>>,
    pub merkle_paths: Vec<Vec<Option<F>>>,
    pub leaf_indices: Vec<Option<F>>,
    pub config: ExploitMerkleConfig,
}

impl<F: PrimeField> ExploitMerkleCircuit<F> {
    pub fn from_report(
        report_content: &str,
        contract_address: &str,
        exploit_signature: &str,
        config: ExploitMerkleConfig,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let chunks = chunk_content(report_content, config.chunk_size);
        let exploit_chunks = find_exploit_chunks(&chunks, exploit_signature, &config)?;
        let merkle_tree = build_merkle_tree(&chunks, config.tree_height)?;
        
        let merkle_root = Some(bytes_to_field_element(&merkle_tree.root));
        let contract_addr = Some(bytes_to_field_element(contract_address.as_bytes()));
        
        let exploit_chunk_fields: Vec<Option<F>> = exploit_chunks.chunk_data
            .iter()
            .map(|chunk| Some(bytes_to_field_element(chunk)))
            .collect();
        
        let merkle_path_fields: Vec<Vec<Option<F>>> = exploit_chunks.merkle_paths
            .iter()
            .map(|path| {
                path.iter()
                    .map(|node| Some(bytes_to_field_element(node)))
                    .collect()
            })
            .collect();
        
        let leaf_index_fields: Vec<Option<F>> = exploit_chunks.chunk_indices
            .iter()
            .map(|&idx| Some(F::from(idx as u64)))
            .collect();
        
        Ok(Self {
            merkle_root,
            contract_address: contract_addr,
            exploit_chunks: exploit_chunk_fields,
            merkle_paths: merkle_path_fields,
            leaf_indices: leaf_index_fields,
            config,
        })
    }
    
    fn validate_merkle_paths(
        &self,
        _cs: ConstraintSystemRef<F>,
        chunk_vars: &[FpVar<F>],
        path_vars: &[Vec<FpVar<F>>],
        index_vars: &[FpVar<F>],
        root_var: &FpVar<F>,
    ) -> Result<(), SynthesisError> {
        for (i, chunk_var) in chunk_vars.iter().enumerate() {
            let path = &path_vars[i];
            let index = &index_vars[i];
            let computed_root = self.compute_merkle_root(chunk_var, path, index)?;
            computed_root.enforce_equal(root_var)?;
        }
        Ok(())
    }
    
    fn compute_merkle_root(
        &self,
        leaf: &FpVar<F>,
        path: &[FpVar<F>],
        _index: &FpVar<F>,
    ) -> Result<FpVar<F>, SynthesisError> {
        let mut current = leaf.clone();
        
        for sibling in path {
            current = &current + sibling;
        }
        
        Ok(current)
    }
}

impl<F: PrimeField> ConstraintSynthesizer<F> for ExploitMerkleCircuit<F> {
    fn generate_constraints(self, cs: ConstraintSystemRef<F>) -> Result<(), SynthesisError> {
        // Public inputs: merkle root and contract address
        let root_var = FpVar::<F>::new_input(cs.clone(), || {
            self.merkle_root.ok_or(SynthesisError::AssignmentMissing)
        })?;
        
        let contract_addr_var = FpVar::<F>::new_input(cs.clone(), || {
            self.contract_address.ok_or(SynthesisError::AssignmentMissing)
        })?;
        
        // Private witnesses: exploit chunks and their merkle paths
        let chunk_vars: Result<Vec<_>, _> = self.exploit_chunks
            .iter()
            .map(|chunk| {
                FpVar::<F>::new_witness(cs.clone(), || {
                    chunk.ok_or(SynthesisError::AssignmentMissing)
                })
            })
            .collect();
        let chunk_vars = chunk_vars?;
        
        let path_vars: Result<Vec<Vec<_>>, _> = self.merkle_paths
            .iter()
            .map(|path| {
                path.iter()
                    .map(|node| {
                        FpVar::<F>::new_witness(cs.clone(), || {
                            node.ok_or(SynthesisError::AssignmentMissing)
                        })
                    })
                    .collect()
            })
            .collect();
        let path_vars = path_vars?;
        
        let index_vars: Result<Vec<_>, _> = self.leaf_indices
            .iter()
            .map(|idx| {
                FpVar::<F>::new_witness(cs.clone(), || {
                    idx.ok_or(SynthesisError::AssignmentMissing)
                })
            })
            .collect();
        let index_vars = index_vars?;
        
        let zero = FpVar::zero();
        
        // Constraint 1: Validate exploit chunks are non-empty
        for chunk_var in &chunk_vars {
            let is_zero = chunk_var.is_eq(&zero)?;
            is_zero.enforce_equal(&Boolean::constant(false))?;
        }
        
        // Constraint 2: Validate contract address is non-zero
        let addr_is_zero = contract_addr_var.is_eq(&zero)?;
        addr_is_zero.enforce_equal(&Boolean::constant(false))?;
        
        // Constraint 3: Validate merkle root is non-zero
        let root_is_zero = root_var.is_eq(&zero)?;
        root_is_zero.enforce_equal(&Boolean::constant(false))?;
        
        // Constraint 4: Simple merkle path validation (sum-based for demonstration)
        // In a real implementation, this would use proper hash-based merkle proofs
        for (i, chunk_var) in chunk_vars.iter().enumerate() {
            if i < path_vars.len() && i < index_vars.len() {
                let path = &path_vars[i];
                let _index = &index_vars[i];
                
                // Simple constraint: sum of path nodes should relate to the root
                // This is a placeholder - real implementation would use hash constraints
                let mut path_sum = chunk_var.clone();
                for sibling in path {
                    path_sum = &path_sum + sibling;
                }
                
                // Ensure the path sum is meaningful (not zero)
                let sum_is_zero = path_sum.is_eq(&zero)?;
                sum_is_zero.enforce_equal(&Boolean::constant(false))?;
            }
        }
        
        // Constraint 5: Ensure indices are within valid range if we have multiple chunks
        if chunk_vars.len() > 1 {
            for i in 1..index_vars.len() {
                let prev_plus_one = &index_vars[i - 1] + FpVar::one();
                index_vars[i].enforce_equal(&prev_plus_one)?;
            }
        }
        
        Ok(())
    }
}

fn chunk_content(content: &str, chunk_size: usize) -> Vec<Vec<u8>> {
    let bytes = content.as_bytes();
    let mut chunks = Vec::new();
    
    for chunk_start in (0..bytes.len()).step_by(chunk_size) {
        let chunk_end = std::cmp::min(chunk_start + chunk_size, bytes.len());
        let mut chunk = bytes[chunk_start..chunk_end].to_vec();
        
        while chunk.len() < chunk_size {
            chunk.push(0);
        }
        
        chunks.push(chunk);
    }
    
    chunks
}

fn find_exploit_chunks(
    chunks: &[Vec<u8>],
    exploit_signature: &str,
    config: &ExploitMerkleConfig,
) -> Result<ExploitChunks, Box<dyn std::error::Error>> {
    let mut full_content = Vec::new();
    for chunk in chunks {
        full_content.extend_from_slice(chunk);
    }
    
    let content_str = String::from_utf8_lossy(&full_content);
    let signature_start = content_str.find(exploit_signature)
        .ok_or("Exploit signature not found in content")?;
    
    let signature_end = signature_start + exploit_signature.len();
    let mut chunk_indices = Vec::new();
    let mut current_pos = 0;
    
    for (i, chunk) in chunks.iter().enumerate() {
        let chunk_end = current_pos + chunk.len();
        
        if current_pos < signature_end && chunk_end > signature_start {
            chunk_indices.push(i);
        }
        
        current_pos = chunk_end;
        
        if chunk_indices.len() >= config.max_exploit_chunks {
            break;
        }
    }
    
    let chunk_data: Vec<Vec<u8>> = chunk_indices
        .iter()
        .map(|&idx| chunks[idx].clone())
        .collect();
    
    let merkle_paths: Vec<Vec<Vec<u8>>> = chunk_indices
        .iter()
        .map(|_| {
            (0..config.tree_height)
                .map(|_| vec![0u8; 32])
                .collect()
        })
        .collect();
    
    Ok(ExploitChunks {
        chunk_indices,
        chunk_data,
        merkle_paths,
    })
}

fn build_merkle_tree(
    chunks: &[Vec<u8>],
    height: u32,
) -> Result<SimpleMerkleTree, Box<dyn std::error::Error>> {
    use std::hash::Hasher;
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    
    for chunk in chunks {
        hasher.write(chunk);
    }
    
    let root_hash = hasher.finish().to_be_bytes().to_vec();
    
    Ok(SimpleMerkleTree {
        root: root_hash,
        leaves: chunks.to_vec(),
        height,
    })
}

fn bytes_to_field_element<F: PrimeField>(bytes: &[u8]) -> F {
    use std::hash::Hasher;
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    hasher.write(bytes);
    let hash = hasher.finish();
    F::from(hash)
}

#[cfg(test)]
mod tests {
    use super::*;
    use ark_bn254::Fr;

    #[test]
    fn test_chunk_content() {
        let content = "Hello, World! This is a test.";
        let chunks = chunk_content(content, 8);
        
        assert!(!chunks.is_empty());
        assert_eq!(chunks[0].len(), 8);
    }
    
    #[test]
    fn test_exploit_circuit_creation() {
        let report = "This is a vulnerability report with reentrancy_attack_vector_detected in the contract.";
        let contract_addr = "0x1234567890abcdef1234567890abcdef12345678";
        let exploit_sig = "reentrancy_attack_vector_detected";
        let config = ExploitMerkleConfig::default();
        
        let circuit = ExploitMerkleCircuit::<Fr>::from_report(
            report,
            contract_addr,
            exploit_sig,
            config,
        );
        
        assert!(circuit.is_ok());
        let circuit = circuit.unwrap();
        assert!(circuit.merkle_root.is_some());
        assert!(circuit.contract_address.is_some());
        assert!(!circuit.exploit_chunks.is_empty());
    }
}
